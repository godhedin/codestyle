# Принципы рефакторинга Avataria3D

## 1. Общие подходы
- Любой рефакторинг должен приводить к более чистой, поддерживаемой и модульной архитектуре.
- Необходимо устранять устаревшие паттерны и антипаттерны, заменяя их на современные решения, используемые в разрешённых пакетах.
- Все изменения должны быть обратимо совместимыми, если не указано иное.

## 2. Серверная часть (Java)
- Заменять DAO-классы и ручные модели на Spring Data репозитории и Entity-классы с аннотациями JPA/Aerospike.
- Использовать подходы из пакетов `com.tortuga.avaland.meta.wishlist` и `com.tortuga.avaland.meta.messenger`.
- Исключить прямое использование SQL/JDBC, все доступы к данным — только через репозитории.
- Все новые API реализовывать как REST-контроллеры, а не через TCP/Netty.
- Если необходимы задачи по расписанию (Scheduler), использовать только подход Spring: аннотации `@Scheduled`, сервисы и конфигурирование через Spring.
- Обработку событий (event handling) реализовывать асинхронно — через Spring `@Async`, очереди или другие современные подходы.
- Ошибки в необязательных сервисах логировать на уровне INFO, не выбрасывать наружу.

## 3. Клиентская часть (Unity/C#)
- Все сетевые запросы реализовывать через HTTP-клиенты и REST API, не использовать старые TCP-команды.
- Убирать классы с постфиксом `Module`, которые конфигурируют DI. Вместо этого помечать сервисы, репозитории и другие классы соответствующими атрибутами (`[Service]`, `[Repository]` и др.).
- Сервисы должны быть оформлены с атрибутом `[Service]` и внедряться через DI.
- Если сервис наследуется от `GameEventDispatcher` или `EventDispatcher`, то для диспатча событий создавать отдельный класс с постфиксом `Dispatcher` (например, `XxxDispatcher`) и диспатчить события только через него, а не через сам сервис.
- Разделять сервисы на Stateless и Stateful:
    - **Stateless сервисы**:
        - Содержат только чистую бизнес-логику
        - Не хранят состояние
        - Используются для конкретных операций
        - Пример:
          ```csharp
          [Service]
          public class WishlistOperationService {
              public async UniTask<WishlistOperation> Add(string itemId) {
                  // Чистые операции без состояния
              }
          }
          ```
    - **Stateful сервисы**:
        - Управляют состоянием
        - Содержат события для оповещения об изменениях
        - Координируют работу stateless сервисов
- Если требуется межмодульное взаимодействие, выносить его в отдельный класс с использованием Mediator-паттерна:
    - Использовать Mediator для коммуникации между модулями
    - Обеспечивать слабую связанность модулей
    - Централизованно обрабатывать межмодульные события
    - Пример:
      ```csharp
      [Mediator]
      public class InventoryWishlistMediator : MonoBehaviour, IServiceInitable {
          [Inject]
          private ClothesInventoryService _clothesInventoryService;
          [Inject]
          private WishlistService _wishlistService;
      }
      ```
- Ошибки в необязательных сервисах логировать на уровне Info/Warning, не показывать пользователю.
- Все асинхронные операции реализовывать через UniTask и async/await.
- Следовать архитектурным и код-стайл стандартам, описанным в CLAUDE.md.

## 4. Общие требования к задачам
- В каждой задаче по рефакторингу указывать ссылку на этот документ.
- В описании задачи явно указывать, какие классы/модули должны быть приведены к этим принципам.
- В задачах по миграции указывать, что миграция данных не требуется, если не оговорено отдельно.

---

_Этот документ предназначен для использования в качестве стандарта при постановке и выполнении задач по рефакторингу в проекте Avataria3D._
