# Avataria3D Project Guide

## Общее описание проекта

Avataria3D - это многопользовательская игра в жанре виртуального мира/метавселенной для мобильных устройств. Проект предоставляет пользователям возможность создавать персонажей, взаимодействовать друг с другом и исследовать различные игровые локации.

### Технический стек:
- **Клиент**: Unity/C#
- **Сервер**: Java
- **Коммуникация**:
  - HTTP для большинства взаимодействий клиент-сервер
  - Netty TCP для части, отвечающей за игровой мир и синхронизацию в реальном времени

## Структура проекта

Проект состоит из двух основных частей:
- **client** - клиентская часть, написанная на Unity/C#
- **server** - серверная часть, написанная на Java
- **resources** - ресурсы проекта (графика, звуки, локализация и т.д.)

## Клиентская часть (Unity)

### Важные директории:
- `client/Assets/Scripts/Avataria3d` - основные скрипты проекта
- `client/Assets/Scripts/GameKit` - вспомогательные утилиты и фреймворки
- `resources` - ресурсы проекта (текстуры, модели, звуки и т.д.)
- `client/Assets/Scenes` - сцены Unity

### Работа с ресурсами:
- Для управления ресурсами используется система **Addressables**
- Все ресурсы (модели, текстуры, префабы, и т.д.) должны загружаться через Addressables API
- Не рекомендуется использовать прямые ссылки на ресурсы или Resources.Load
- Преимущества использования Addressables:
  - Асинхронная загрузка
  - Оптимизация памяти
  - Управление жизненным циклом ресурсов
  - Возможность удаленной загрузки ресурсов
- Пример загрузки:
  ```csharp
  // Загрузка с помощью Addressables и UniTask
  async UniTask<GameObject> LoadPrefabAsync(string key)
  {
      var handle = await Addressables.LoadAssetAsync<GameObject>(key).ToUniTask();
      return handle.Result;
  }
  ```
- Убедитесь, что все загруженные ресурсы корректно выгружаются когда они больше не нужны

### Асинхронное программирование:
- Для асинхронных операций используется **UniTask** вместо стандартных корутин
- Coroutines (StartCoroutine/IEnumerator) не используются в проекте
- Преимущества UniTask:
  - Более эффективное выполнение (меньшие накладные расходы)
  - Поддержка async/await синтаксиса C#
  - Лучшая обработка ошибок
  - Возможность отмены операций
  - Более чистый и читаемый код
- Примеры использования:
  ```csharp
  // Асинхронная загрузка данных
  public async UniTask<UserData> LoadUserDataAsync(string userId)
  {
      var response = await httpClient.GetAsync($"users/{userId}").ToUniTask();
      return JsonUtility.FromJson<UserData>(response);
  }
  
  // Ожидание с отменой
  async UniTask DelayWithCancellation(int milliseconds, CancellationToken token)
  {
      await UniTask.Delay(milliseconds, cancellationToken: token);
      Debug.Log("Задержка завершена или операция отменена");
  }
  ```
- При работе с Unity API, которые возвращают корутины, используйте методы-расширения для конвертации в UniTask

### Сборка проекта
- Проект использует Unity для клиентской части
- Для сборки можно использовать скрипты `build.cake`

### C# Code Conventions:
- Следовать C# coding conventions описанным в: https://github.com/godhedin/codestyle/blob/main/unity-style.md
- Обязательно использовать фигурные скобки в if, for, while конструкциях, даже если внутри только одна строка
- Именование:
  - Классы и методы: PascalCase (например, `PlayerController`, `GetHealth`)
  - Приватные поля: camelCase с префиксом подчеркивания (например, `_playerHealth`)
  - Публичные поля: PascalCase (например, `PlayerHealth`)
  - Локальные переменные: camelCase (например, `currentHealth`)
  - Интерфейсы: PascalCase с префиксом 'I' (например, `IPlayerController`)
  - Enum типы: PascalCase (например, `PlayerState`)
  - Enum значения: UPPER_SNAKE_CASE как в Java (например, `PlayerState.RUNNING`)
- Организация кода:
  - Публичные члены идут перед защищенными и приватными
  - В одном файле должен быть только один публичный класс
  - Сортировка членов класса: поля, свойства, конструкторы, методы
  - Соблюдать порядок модификаторов доступа: public, protected, private
- Форматирование:
  - Отступы: 4 пробела, не использовать табуляцию
  - Максимальная длина строки: 120 символов
  - Открывающая фигурная скобка на той же строке для методов и классов
- Unity-специфические конвенции:
  - Избегать использования Find, GetComponent в Update или частых методах
  - Кэшировать ссылки на компоненты в Start/Awake
  
  - Избегать монобехейвиоров, где это возможно, использовать обычные C# классы

### Архитектурные принципы:
- Структурировать код по модульному принципу:
  ```
  ModuleName/
  ├── Service/     # Сервисы модуля
  ├── UI/          # UI компоненты
  ├── Dto/         # Объекты передачи данных
  ├── Mediator/    # Межмодульное взаимодействие
  ├── Event/       # События модуля
  ├── Configs/     # Конфигурации
  ├── Model/       # Модели данных
  ├── Api/         # API клиент
  ├── Repo/        # Репозитории
  └── Net/         # Сетевое взаимодействие
  ```
- Разделять сервисы на два типа:
  - Stateless - содержат только чистую бизнес-логику без хранения состояния
  - Stateful - управляют состоянием и используют события для оповещения об изменениях
- Использовать Presenter Pattern для отделения логики UI от бизнес-логики:
  - UI компоненты не содержат бизнес-логику
  - Presenter отвечает за подготовку данных для UI
- Применять Mediator Pattern для межмодульного взаимодействия:
  - Слабая связанность модулей
  - Централизованная обработка межмодульных событий
- Использовать систему событий для асинхронной коммуникации:
  - Типизированные события для каждого модуля
  - Константы для именования событий
- Работать с данными через репозитории:
  - Единый интерфейс для разных типов хранилищ
  - Инкапсуляция логики хранения
- Применять Dependency Injection через атрибуты:
  - Использовать атрибуты [Service], [Repository], [Presenter]
  - Внедрять зависимости через конструктор или поля с [Inject]
  - Определять явно Scope сервиса где необходимо

### Антипаттерны (чего следует избегать):
- Прямое обращение UI к репозиториям
- Бизнес-логика в UI компонентах
- Сильная связанность между модулями
- Хранение состояния в stateless сервисах
- Прямая коммуникация между модулями без Mediator
- Service Locator pattern вместо Dependency Injection

### Unity Best Practices:
- Применять архитектурные паттерны (MVC, MVP, MVVM)
- Использовать систему событий для снижения связанности кода
- Применять принципы SOLID
- Вынести бизнес-логику из MonoBehaviour классов в обычные C# классы
- Оптимизировать производительность:
  - Использовать объектные пулы для часто создаваемых объектов
  - Минимизировать использование FindObjectOfType и GameObject.Find
  - Избегать GetComponent в Update и других частых методах
  

## Серверная часть (Java)

### Технический стек сервера:
- **Java 11+**
- **Spring Framework** - основной фреймворк для HTTP части сервера
- **Spring Boot** - для автоконфигурации и управления зависимостями
- **Spring Web** - для REST API
- **Spring Data** - для работы с базами данных
- **Spring Security** - для авторизации/аутентификации
- **Netty** - для низкоуровневого TCP взаимодействия в игровом мире

### Текущая реализация:
- `server/ava3d-server` - основной монолитный сервер приложения
- Вся серверная логика в настоящее время сосредоточена в этом компоненте

### Планируемая микросервисная архитектура (будущее):
Проект планируется разделить на микросервисы:
- `user-service`
- `messenger-service`
- `avatar-service`
- и другие

### Java Code Conventions:
- Следование стандартным соглашениям Oracle Java Code Conventions
- Именование:
  - Классы: PascalCase (например, `UserController`)
  - Методы и переменные: camelCase (например, `getUserById`)
  - Константы: UPPER_SNAKE_CASE (например, `MAX_USERS_PER_ROOM`)
- Отступы: 4 пробела, не использовать табуляцию
- Максимальная длина строки: 120 символов
- Документировать публичные API с использованием JavaDoc
- Избегать magic numbers и hardcoding значений, использовать константы

### Spring Best Practices:
- Использовать dependency injection через конструкторы
- Предпочитать аннотации конфигурации через XML
- Применять слоистую архитектуру:
  - Controller -> Service -> Repository
- Для REST API:
  - Использовать только HTTP методы GET и POST
  - GET для получения данных
  - POST для всех операций изменения данных (создание, обновление, удаление)
  - Возвращать корректные HTTP статус-коды
  - Структурировать URL'ы по ресурсам, не по действиям
- Использовать DTO объекты для передачи данных между слоями
- Обрабатывать исключения через `@ExceptionHandler` и `ControllerAdvice`
- Использовать Spring Security для авторизации и аутентификации

### Работа с данными:
- Данные хранятся в двух типах БД:
  - Реляционная БД MySQL - для структурированных данных, требующих сложных выборок
  - NoSQL Aerospike - для постоянных данных, которые часто обновляются, но не требуют сложных выборок; используется для снижения нагрузки на реляционную БД
- Доступ к данным осуществляется ТОЛЬКО через Spring Data
- Прямое использование JDBC, SQL-запросов или других способов доступа к данным считается legacy и не рекомендуется
- Использовать репозитории Spring Data для абстрагирования от конкретной реализации БД


### Запуск серверной части
- Используется Docker и docker-compose
- Основные базы данных: MySQL и Aerospike
- RabbitMQ для обмена сообщениями
- Zipkin для трассировки



## Конфигурация

### Технические конфигурации (Config)
- Технические настройки называются "config" и используются для настройки системных компонентов 
- Примеры: доступ к БД, настройки сервера, сетевые параметры
- Технические конфигурации предпочтительно хранить в YAML-формате, в соответствии с принципами Spring
- Расположение конфигов: `server/ava3d-server/src/main/resources/application.yml` и другие файлы yaml в данном каталоге
- Локальные конфигурации: `server/ava3d-server/config`

### Игровые настройки (Descriptor)
- Игровые настройки называются "descriptor" 
- Используются для хранения игровых параметров, настроек и игровой логики
- Хранятся в JSON-формате
- Расположение дескрипторов: `server/ava3d-server/src/main/resources/descriptors`
- Примеры дескрипторов: настройки уровней, параметры персонажей, игровой баланс

### Принципы работы с конфигурацией и дескрипторами
- Изменение конфигов требует перезапуска соответствующих сервисов
- Все значения параметров следует хранить в конфигах и дескрипторах, а не хардкодить в коде

## Процесс разработки

### Рабочий процесс
- Использование Git для контроля версий
- Ветка **develop** - основная рабочая ветка
- Для новых функций создавайте отдельные ветки с префиксом `feature/`
- Для исправления ошибок используйте префикс `fix/`
- Перед слиянием используйте pull request и код-ревью
- Правила именования коммитов:
  ```
  [TYPE]: краткое описание

  Подробное описание, если необходимо
  ```
  где TYPE может быть: FEAT, FIX, REFACTOR, DOCS, TEST и т.д.

### Работа с кодовой базой
- **ВАЖНО**: В проекте присутствует большое количество legacy-кода
- При поиске примеров и шаблонов обращаться только к разрешенным пакетам:
  - **Сервер**: 
    - `com.tortuga.avaland.meta.wishlist`
    - `com.tortuga.avaland.meta.messenger`
  - **Клиент**: 
    - `Avataria3d.Game.SocialModule`
- Код из других пакетов может содержать устаревшие подходы и антипаттерны
- При создании новой функциональности использовать только подходы из рекомендуемых пакетов
- В случае работы с legacy-кодом консультироваться с тимлидом перед внесением изменений

### Языки коммуникации и документации
- Основное общение в команде ведется на **русском** языке
- Весь код, комментарии, имена переменных, функций и классов должны быть на **английском** языке
- Коммиты, pull request'ы и технические описания в системе контроля версий - на английском
- Документация API и технических интерфейсов - на английском
- Пользовательская документация и описание бизнес-требований могут быть на русском
- Все идентификаторы и системные элементы в коде должны иметь осмысленные английские названия

### CI/CD
- Jenkins используется для автоматизации сборки и деплоя
- Автоматическое тестирование запускается при каждом пуше
- Для успешного прохождения CI все тесты должны быть пройдены
- Документация по CI/CD находится в каталоге `/jenkins`

## Интеграция клиент-сервер

### REST API
- Взаимодействие по HTTP осуществляется через REST API
- Документация API автоматически генерируется с помощью Swagger
- Доступ к документации API: `http://localhost:8080/swagger-ui.html` при запущенном сервере

### Обмен данными в реальном времени
- Для коммуникации в реальном времени используется Netty TCP
- Протокол обмена - бинарный, использует систему аннотаций для сериализации/десериализации
- Классы данных помечаются аннотацией `@TransferClass`, поля - `@TransferField`
- Пример:
  ```java
  @TransferClass("u.info")
  public class UserInfoCommand implements ServerCommand {
      @TransferField("uid")
      private long userId;
      
      @TransferField("name")
      private String userName;
      
      // Геттеры и сеттеры...
  }
  ```
- Клиент использует специальную библиотеку для соединения
- События синхронизации обрабатываются в `client/Assets/Scripts/Avataria3d/Net`

### Формат данных
- JSON для HTTP взаимодействия
- Бинарный формат для TCP взаимодействия
- Схемы данных определены в DTO классах
- Версионирование API для обеспечения обратной совместимости

## Управление версиями и релизы

### Версионирование
- Используется Semantic Versioning (SemVer): MAJOR.MINOR.PATCH
- MAJOR - несовместимые API изменения
- MINOR - добавление функциональности с обратной совместимостью
- PATCH - исправления багов с обратной совместимостью
- Версия проекта хранится в `version.ini` файле



## Системный мониторинг и логирование

### Логирование
- Сервер использует Log4j2 для логирования
- Клиентская часть использует Unity Debug и NLog для структурированного логирования
- Уровни логирования: DEBUG, INFO, WARN, ERROR
- Логи сервера хранятся в `server/ava3d-server/logs`

### Мониторинг
- Мониторинг сервера происходит через Prometheus и Grafana
- Метрики собираются для анализа производительности и стабильности
- Алерты настроены для оповещения о проблемах
- Дашборды с основными показателями доступны для всей команды

### Отслеживание ошибок
- Используется система для отслеживания ошибок
- Все необработанные исключения автоматически логируются
- Клиентские ошибки отправляются на сервер для анализа
- Регулярные отчеты о стабильности формируются на основе собранных данных


